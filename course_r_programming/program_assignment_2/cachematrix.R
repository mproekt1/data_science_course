###############################################################################
#Function makeCacheMatrix create a cachable matrix
# * the matrix cached either during initalixation (x <- makeCacheMatrix(1:4))
# * or using sub-function set.matrix (x <- makeCacheMatrix(); x$set.matrix(1:4))
#
#Function makeCacheMatrix also performs data validation:
# * cached value is a marix
# * cached matrix is a square
# * cached matrix is inversable
###############################################################################
makeCacheMatrix <- function(x = matrix()) {
  #x holds cached matrix
  #validate x class
  if(class(x) != "matrix"){
    stop("must be matrix")
  }
  
  #x mast be a square for inverse
  if(ncol(x) != nrow(x)){
    stop("must be square")
  }
  
  #x must be inversable
  if(!is.nan(det(x)) & det(x) == 0){
    stop("matrix is not inversable")
  }
  
  matrix_inv <- NULL #initialize matrix_inv
  
  #cach matrix
  set.matrix <- function(new_matrix){
    #validate new_matrix
    if(class(new_matrix) != "matrix"){
      stop("must be matrix")
    }

    #x mast be a square for inverse
    if(ncol(new_matrix) != nrow(new_matrix)){
      stop("must be square")
    }

    #x must be inversable
    if(!is.nan(det(new_matrix)) & det(new_matrix) == 0){
      stop("matrix is not inversable")
    }
    
    #store new matrix
    x <<- new_matrix
    
    #reset inverse of matrix when a new matrix is assgined
    matrix_inv <<- NULL
  }
  
  #return cached matrix
  get.matrix <- function(){
    x
  }
  
  #cach matrix inverse
  set.inverse <- function(inverse){
    #validate inverse
    if(class(inverse) != "matrix"){
      stop("must be matrix")
    }

    #x mast be a square for inverse
    if(ncol(inverse) != nrow(inverse)){
      stop("must be square")
    }
    
    matrix_inv <<- inverse
  }
  
  #return cached matrix inverse
  get.inverse  <- function(){
    matrix_inv
  }
  
  list(set.matrix = set.matrix, get.matrix = get.matrix, set.inverse = set.inverse, get.inverse = get.inverse)

}


###############################################################################
#Function cacheSolve computes the inverse for matrix cached using makeCacheMatrix
#If the inverse has already been calculated, cacheSolve returns previously cached inverse
###############################################################################
cacheSolve <- function(x, ...) {
  #x is matrix cach generated by makeCacheMatrix
  #and passed as an input parameter
  
  #get cached inverse value
  inverse <- x$get.inverse()
  
  #was inverse already cached?
  if(!is.null(inverse)){
    #return previously cached inverse
    message("getting cached inverse")
    return(inverse)
  }
  
  #no previously cached inverse
  #x was either just initialized in makeCacheMatrix without default value
  #or x value was reset using set.inverse
  
  #get matric from matrix cach x
  cached_matrix <- x$get.matrix()
  
  #calculate inverse of cached matrix
  inverse <- solve(cached_matrix)
  
  #cach inverse
  x$set.inverse(inverse = inverse)
  
  #return inverse of cached matrix
  inverse
  
}
